# Keystore

## Theorem 1 - Private Key & Factor definition

When a user registers an account by logging in Arism Wallet with a third-party provider (eg. Google) for the first time, the wallet application (client) will generate randomly a **Private Key**.

$$
\text{key}_\text{private} \overset{{\scriptscriptstyle{\text{R}}}}{\leftarrow}\mathbb{G}  \mid  \text{client}
$$

User can also provide their existed **Private Key** to the client for preventing this random generation process.

**Private Factor** is the point located on the y-axis in the _Cartesian coordinate system_ with the height is **Private Key** value.

$$
\textbf{Factor}_\text{private} = (0, \text{key}_\text{private})
$$

## Theorem 2 - Distributed Secret Sharing (DSS)

Then the **Arism Network** will execute a bunch of advanced algorithms to take care of creating a **Network Key**. This is called **Distributed Key Generation (DKG)** step.

<figure className="w-full sm:w-1/2 xl:w-1/3 mx-auto">
<img src='/static/img/dss_plot.png'/>
<figcaption>Figure 1: Distributed Secret Sharing (DSS)   process</figcaption>
</figure>

In which, $\Sigma\text{z}_{*}$ is called **Network Key** (or **Master Secret** in the algorithm context). Which is calculated by the sum of the **Master Shares** instead of the sum of the **Secrets**. We will mention this algorithm in the next chapter.

## Theorem 3 - Network Key & Factor definition

**Network Key** is the result of **DKG** process on the **Arism Network**.

$$
\text{key}_\text{network} \leftarrow \text{DSS(\text{OAuth Token})}  \mid  \text{network}
$$

Combine it with $x = 1$, we have **Network Factor** as a point in the _Cartesian coordinate system_, which is represented as below.

$$
\textbf{Factor}_\text{network} = (1, \text{key}_\text{network})
$$

## Theorem 4 - Shamir's Secret Sharing (SSS)

With those two points, we can establish a unique line (i.e a first degree equation) on the _Cartesian coordinate system_ using _Lagrange interpolation_. This is called **Factor's Polynomial**.

The process of creating the **Factor's Polynomial** is called **Shamir's Secret Sharing (SSS)**.

$$
\textbf{P} \leftarrow \text{SSS}(\textbf{Factor}_\text{private}, \textbf{Factor}_\text{network}) \mid \text{client}
$$

## Theorem 5 - Device Key & Factor definition

Once having the **Factor's Polynomial**, we will get a third key called **Device Key** by retrieving the value of the polynomial where $x = 2$. This **Key** is stored in user's device (browser)

$$
\text{key}_\text{device} \leftarrow \textbf{P}(x = 2)
$$

This pair of values will form a point we will call the **Device Factor**.

$$
\textbf{Factor}_\text{device} = (2, \text{key}_\text{device})
$$

## Theorem 6 - Private Key derivation technique

Therefore, every time user logs in later, it's just needed to log in on the original device (to get the **Device Key**) with the registered third-party account (to get the **Network Key**).

Then user can recreate the **Factor's Polynomial** by using _Lagrange interpolation_, and get the **Private Key** by intersecting it with the y-axis (where $x = 0$).

$$
\text{key}_\text{private} \leftarrow \textbf{P}(x = 0)
$$

## Theorem 7 - Multi-Factor Authentication (MFA)

User can optionally turn on the **Multi-Factor Authentication (MFA)** feature, this is a recommended feature because if it is turned on, user will be able to log in on a new device, just need the correct password.

## Theorem 8 - Recovery Key & Factor definition

Therefore, there is an additional **Key** which is basically derived from the password and the **Factor's Polynomial**. In which, the x-value of the **Recovery Factor** is the hashed value of the user's password.

$$
\text{x}_\text{recovery} \leftarrow \text{Hash}(\text{password}) \\
$$

But in order to construct the **Recovery Factor**, its y-value on the _Cartesian coordinate system_ is needed. We will restore the **Factor's Polynomial** by using **Lagrange interpolation** for 2 out of **Private Factor**, **Network Factor** and **Device Factor**.

$$
\textbf{P} \leftarrow \text{SSS}(\textbf{Factor}_0, \textbf{Factor}_1) \mid \text{client}
$$


Then, we can get the y-value of the **Recovery Factor** by substituting the **Factor's Polynomial** with the x-value.

$$
\text{key}_\text{recovery} \leftarrow \textbf{P}\left(x = \text{x}_\text{recovery}\right)
$$

We will have the **Recovery Factor** as a point in the _Cartesian coordinate system_.

$$
\textbf{Factor}_\text{recovery} = \left(\text{x}_\text{recovery}, \text{key}_\text{recovery}\right)
$$

The value $x_\text{recovery}$ will be stored in to our **Metadata Storage** for the purpose of combining with the user's password to recreate the **Recovery Factor** when needed. Obviously this doesn't need security because only this x-value alone can't cause any vulnerability to the system.

## Theorem 9 - Private Key derivation threshold

Overall, whenever user logs in, there is only 2/3 **Factors** needed to be provided: **Network Factor**, **Device Factor** and **Recovery Factor** (if **MFA** is turned on).

## Theorem 10 - Multi-key generation

With the same idea to how **Recovery Key** is generated, user can generate as many keys as they want, called **Child Keys** (or child wallets). When generating a new key, the client will generate randomly a new **Private Key**.

$$
\text{x}_\text{private}' \overset{{\scriptscriptstyle{\text{R}}}}{\leftarrow}\mathbb{G}  \mid  \text{client}
$$

Then, the **Factor's Polynomial** will be restored by using **Lagrange interpolation** for 2 out of **Private Factor**, **Network Factor**, **Device Factor**, or **Recovery Factor**.

$$
\textbf{P} \leftarrow \text{SSS}(\textbf{Factor}_0, \textbf{Factor}_1) \mid \text{client}
$$

The x-value will then be the value that when substituted it into the **Factor's Polynomial**, the result will be the **Private Key**.

$$
\text{key}_\text{private}' \leftarrow \textbf{P}\left(x = \text{x}_\text{private}'\right)
$$

The values $\text{x}_\text{private}'$ will be stored in to our **Metadata Storage** for the purpose of combining with the **Factor's Polynomial** to derive all the **Child Keys** $\text{key}_\text{private}'$ when needed.